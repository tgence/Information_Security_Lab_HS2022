theory EncryptedDH2
begin

/* Signed Diffie-Hellman protocol, second attempt:
   A -> B : A, aenc_B{A, g^x}  (x fresh)
   B -> A : B, aenc_A{B, g^y, h(g^x)}  (y fresh)
   A -> B : A, aenc_B{A, h(g^y)}  */


/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in Diffie-Hellman, asymmetric encryption and hashing equational theories */
builtins: diffie-hellman, asymmetric-encryption, hashing



/* ------------------ */
/* Key infrastructure */
/* ------------------ */

rule genkey: 
   [ Fr(~kA) ] 
   -->
   [ !Key($A, ~kA),  
     !Pk($A, pk(~kA)),
     Out(pk(~kA)) ]


/* Question 6*/

/*----------------*/
/* Protocol rules */
/*----------------*/


/* Initiator role */
rule Init_1:
let gxI = 'g'^~xI 
  in         
  [ 
    Fr(~xI),
    !Pk($B, pkB) 
  ]             
   
  -->

  [ 
    Init_1($A, $B, ~xI, gxI),
    Out(aenc(<$A,gxI>, pkB)) 
  ]  


/* Responder role */
rule Resp_1:
  let gyR = 'g'^~yR
      d1_message = adec(e1_message, skB) 
      dgxI  = snd(d1_message)
      g_xy = dgxI^~yR 
      in
      [ 
        !Key($B, skB),
        !Pk($A, pkA),
        Fr(~yR),
        In(e1_message)               
      ]               
  
      --[
          RunningR($B, $A, g_xy),
          Eq($A, fst(d1_message))
      ]->

     [ 
       Resp_1($A, $B, ~yR, gyR, dgxI, skB), 
       Out(aenc(<$B, gyR, h(dgxI)>, pkA)) 
     ]


/* Initiator role */
rule Init_2:
  let d2_message = adec(e2_message, skA)
      dgyR = fst(snd(d2_message))
      dghxI = snd(snd(d2_message))
      g_xy = dgyR^~xI
  in
  [ 
    Init_1($A, $B, ~xI, gxI),
    !Key($A, skA),
    !Pk($B, pkB),
    In(e2_message)
  ]

   --[ FinishedI($A),          
       SecretI($A, $B , g_xy),
       Eq(h(gxI), dghxI),
       Eq($B, fst(d2_message)),
       CommitI($A, $B, g_xy),
       RunningI($A, $B, g_xy)
    ]->      

   [Out(aenc(<$A, h(dgyR)>, pkB))]



/* Responder role */
rule Resp_2:
  let d3_message = adec(e3_message, skB)
      dhgyR = snd(d3_message)
      g_xy = gxI^~yR
  in
  [
   Resp_1($A, $B, ~yR, gyR, gxI, skB),
   In(e3_message)
  ]

  --[ 
      FinishedR($B),             
      SecretR($A, $B, g_xy),
      Eq(h(gyR), dhgyR),
      Eq($A, fst(d3_message)),
      CommitR($B, $A, g_xy)
   ]->

  []


/* ---------- */
/* Key Reveal */
/* ---------- */

/* Question 2 here */


rule Publish_secretK:
[!Key(A, k)]

--[Compromised(A)]->

[Out(k)]

/* ---------- */
/* Restrictions */
/* ---------- */

restriction equality:
"All x y #i. Eq(x,y) @i ==> x = y"


/* ---------- */
/* Properties */
/* ---------- */

/* Executability checks */
lemma executableI:
exists-trace "Ex #i A. FinishedI(A) @ i & not (Ex #j B. Compromised(B)@j)"

lemma executableR:
exists-trace "Ex #i B. FinishedR(B) @ i & not (Ex #j B. Compromised(B)@j)"


/* Secrecy and agreement properties */

lemma key_secrecyI:
"All #i A B k.
 (SecretI(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"

lemma key_secrecyR:
"All #i A B k.
 (SecretR(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"


lemma agreementR:
"All #i A B k.
  (CommitR( B, A, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningI(A, B, k) @ j & j < i)"

lemma agreementI:
"All #i A B k.
  (CommitI( A, B, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningR(B, A, k) @ j & j < i)"


end



